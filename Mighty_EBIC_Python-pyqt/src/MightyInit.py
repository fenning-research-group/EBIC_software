#!/usr/bin/env python
from __future__ import with_statement
import sys
import os
CWD = os.getcwd()
PWD = os.pardir
sys.path.append(CWD +'/proto_Code')
sys.path.append(CWD)
sys.path.append(PWD)


import os.path

from src import pyqtgraph as pg
import numpy
import scipy
import scipy.ndimage
import h5py
import Mfigure
import math
import pylab
import matplotlib.cm as cm
#import lineProfile
#import EbicCommandManager
import time
#import EbicPythonCommandsAuto
import EbicDataManager
#import WriteToHdf5
import scanUpdate, edm
import thread, Queue
import config
import scanobject
import Mfigure
#import sys
import numpy
import tracker
#from pylab import *
from scipy import mgrid
from time import strftime
from Mexport import Exporter
import socket
import pyQtWindow
#from src import pyqtgraph as pg
import src.pyqtgraph.dockarea as Da
import SetV

IP = "10.0.1.8"
PORT = 9930

#import plotActions
#import regionOfInterest

# used to parse files more easily
#from __future__ import with_statement

# Numpy module
import numpy as np


# for command-line arguments
import sys

# Qt4 bindings for core Qt functionalities (non-GUI)
from PyQt4 import QtCore
# Python Qt4 bindings for GUI objects
from PyQt4 import QtGui

# import the MainWindow widget from the converted .ui files
from qtdesigner import Ui_MplMainWindow


import profileUI
#import reCenterSliceUI
import rCenSliceUI



class DesignerMainWindow(QtGui.QMainWindow, Ui_MplMainWindow):
    """Customization for Qt Designer created window"""
    def __init__(self, parent = None):
        # initialization of the superclass
        super(DesignerMainWindow, self).__init__(parent)
        # setup the GUI --> function generated by pyuic4
        self.setupUi(self)
        self.startpoint= None
        self.endpoint = None
        self.sliceData = None
        self.channelMask= 0b000000 # six channels binary format as a reminder
        self.Oversampling = [0,2,4,8,16,32,64]
        self.OS = 0
        self.ChannelCount = 0
        self.delayInt = 1
        self.Dwell = 0
        self.scanMag = None
        self.Dx = None
        self.Dy = None
        self.pointsV = None
        self.pointsH = None 
        self.progress = [0.0]
        self.cmapList = None
        self.sockQ = None
        self.setSamplesPerPoint(1)
        self.setDelay(5*1e-8) 

        self.setStep(0)  #takes first index of values min is 2**8 in bits 
        self.CH = 0
        self.channel = [0]

        #self.scans = []
        try:
            self.cmapList = pylab.cm._cmapnames
            self.ColorMap.addItems(pylab.cm._cmapnames) #!!! ha this works ,
        except:
            self.cmapList = cm.cmap_d.keys()
            self.cmapList.sort()
            self.ColorMap.addItems(self.cmapList)#cm.cmap_d.keys())


        #self.delayInt = 1


        self.cal = config.getCalibration()
        self.vMagScale = self.cal['vMagScale']
        self.hMagScale = self.cal['hMagScale']
        print self.vMagScale, self.hMagScale
        self.vMin = self.cal['vMin']
        self.hMin = self.cal['hMin']
        self.hMax = self.cal['hMax']
        self.vMax = self.cal['hMax']
        self.hSpread = self.vMax - self.vMin
        self.vSpread = self.hMax - self.hMin
        self.cmap = pylab.cm.Greys_r 

        self.channelUnits = ['','','','','',''] 
        self.channelGain = ['','','','','','']  
        self.channelLabel = ['','','','','','']  
 
        self.mag= None
        self.accel= None
        self.beam = None
        self.ui_tracker = tracker.GuiTracker(self)
        self.scanTracker = tracker.ScanTracker(self)
        self.scans = self.scanTracker.scans #here as a test probably not needed in future

        self.scan = None
        self.im = None

        self.iv_tracker = tracker.IVTracker(self)
        #ToolTracker
        self.ToolTracker = tracker.ToolTracker(self)
        self.ViewTracker = tracker.ViewTracker(self)

        #TODO replaced
        #self.view = pyQtWindow.CustomViewBox(lockAspect=True, invertY = False, invertX = False)
        #self.IView.setCentralItem(self.view)

        #TM adding this as the main way to image a channel
        self.d1 = Da.Dock("EBIC", size=(500,200), autoOrientation = False)
        self.DockMain.addDock(self.d1, 'top')
        self.img = pg.ImageView_MOD(toolState = self.ToolTracker)
        self.d1.addWidget(self.img)
        

        #Dock Area Testing
        self.d5 = Da.Dock("EBIC", size=(500,200), autoOrientation = False)
        
        self.DockTest.addDock(self.d5, 'top')
        self.d5.setOrientation(o = 'vertical', force = True)
        self.w5 = pg.ImageView_MOD(toolState = self.ToolTracker) #changed from pg.ImageView()
        self.w5.setImage(np.random.normal(size=(100,100)))


        self.d5.addWidget(self.w5)

        #pyqtgraph items
        #TODO connect these to ImageViewMOD     
        #what is the purpose of scale here and what vales should be sent to Xhair etc... for the scale???
        #self.Xhair = pyQtWindow.CrossHairs(self.view,1.0)
        #self.pyROI = pyQtWindow.ROI_Rec(self.view, 1.0)
        #self.pyLine = pyQtWindow.LineSeg(self.view, 1.0)
        #self.img = pg.ImageItem()
        #self.view.addItem(self.img)
        #self.scale = 1e-6
        

        # connect the signals with the slots
        QtCore.QObject.connect(self.mplactionOpen, QtCore.SIGNAL('triggered()'), self.select_file)
        QtCore.QObject.connect(self.mplactionQuit, QtCore.SIGNAL('triggered()'), QtGui.qApp, QtCore.SLOT("quit()"))
        QtCore.QObject.connect(self.getBounds_pushButton, QtCore.SIGNAL("clicked()"), self.ui_tracker.getBounds)
        QtCore.QObject.connect(self.SaveButton, QtCore.SIGNAL("clicked()"), self.scanTracker.save)
        QtCore.QObject.connect(self.Channel, QtCore.SIGNAL("valueChanged(int)"), self.setChannel)
        QtCore.QObject.connect(self.analysisCh, QtCore.SIGNAL("currentChanged(int)"), self.scanTracker.figTracker.activeChannel)
        QtCore.QObject.connect(self.OScomboBox, QtCore.SIGNAL("currentIndexChanged(int)"), self.update_OS)



        #SLOTS for setting channels 
        #QtCore.QObject.connect(self.enCh1, QtCore.SIGNAL("stateChanged(int)"), self.setMask)
        #QtCore.QObject.connect(self.enCh2, QtCore.SIGNAL("stateChanged(int)"),self.setMask)
        #QtCore.QObject.connect(self.enCh3, QtCore.SIGNAL("stateChanged(int)"), self.setMask)
        #QtCore.QObject.connect(self.enCh4, QtCore.SIGNAL("stateChanged(int)"), self.setMask)
        #QtCore.QObject.connect(self.enCh5, QtCore.SIGNAL("stateChanged(int)"), self.setMask)
        #QtCore.QObject.connect(self.enCh6, QtCore.SIGNAL("stateChanged(int)"), self.setMask)

        #slot for step size
        QtCore.QObject.connect(self.ScanSize, QtCore.SIGNAL("activated(int)"), self.setStep)

        #slot for changing samples per point
       # QtCore.QObject.connect(self.SamplesPerPoint, QtCore.SIGNAL("valueChanged(int)"), self.setSamplesPerPoint) 

        #slots for changing parameters when text is changed
        #QtCore.QObject.connect(self.Delay, QtCore.SIGNAL("textChanged(QString)"), self.setDelay) 
        #QtCore.QObject.connect(self.Mag, QtCore.SIGNAL("textChanged(QString)"), self.setMag)
        #QtCore.QObject.connect(self.dxMicrons, QtCore.SIGNAL("textChanged(QString)"), self.setDx)
        #QtCore.QObject.connect(self.dyMicrons, QtCore.SIGNAL("textChanged(QString)"), self.setDy)

        #slot that starts a Scan using inputs defined
        QtCore.QObject.connect(self.Scan, QtCore.SIGNAL("clicked()"), self.startScan)
        QtCore.QObject.connect(self.StopScan, QtCore.SIGNAL("clicked()"), self.stopScan)
        QtCore.QObject.connect(self.SetAux1, QtCore.SIGNAL("clicked()"), self.setAux1)
        QtCore.QObject.connect(self.SetAux2, QtCore.SIGNAL("clicked()"), self.setAux2)


        QtCore.QObject.connect(self.updateROI, QtCore.SIGNAL("clicked()"), self.update_scan_ROI)
        QtCore.QObject.connect(self.SaveScan, QtCore.SIGNAL("clicked()"), self.saveScanObject)	
        QtCore.QObject.connect(self.calBounds, QtCore.SIGNAL("clicked()"), self.getCalBounds)
        QtCore.QObject.connect(self.imageBounds, QtCore.SIGNAL("clicked()"), self.getImageBounds)
        QtCore.QObject.connect(self.writeCalibration, QtCore.SIGNAL("clicked()"), self.calibration)
        QtCore.QObject.connect(self.CalScan, QtCore.SIGNAL("clicked()"), self.runCalScan)
        
        QtCore.QObject.connect(self.Sweep, QtCore.SIGNAL("clicked()"), self.takeIV)
        QtCore.QObject.connect(self.SaveSweep, QtCore.SIGNAL("clicked()"), self.saveTransport)
        QtCore.QObject.connect(self.TestProfile, QtCore.SIGNAL("clicked()"), self.test_profile_line)
        QtCore.QObject.connect(self.PlotScansCombo, QtCore.SIGNAL("currentIndexChanged(int)"), self.update_active_scan )
        QtCore.QObject.connect(self.SwapAxes, QtCore.SIGNAL("clicked()"), self.swap_axes)
        QtCore.QObject.connect(self.FlipLR, QtCore.SIGNAL("clicked()"), self.flip_lr)
        QtCore.QObject.connect(self.FlipUD, QtCore.SIGNAL("clicked()"), self.flip_ud)

        #new added for slices
        QtCore.QObject.connect(self.ShowSlice, QtCore.SIGNAL("clicked()"), self.startRCSlice)






        #slots for figTracker
        QtCore.QObject.connect(self.AddPlotScan, QtCore.SIGNAL("clicked()"), self.scanTracker.figTracker.add_image)
        QtCore.QObject.connect(self.RemovePlot, QtCore.SIGNAL("clicked()"), self.scanTracker.figTracker.remove_from_plot)
        QtCore.QObject.connect(self.ColorMap, QtCore.SIGNAL("currentIndexChanged(int)"), self.scanTracker.figTracker.change_cmap )
        QtCore.QObject.connect(self.AddSubPlot, QtCore.SIGNAL("clicked()"), self.scanTracker.figTracker.add_subplot)
        QtCore.QObject.connect(self.SubPlotComobo, QtCore.SIGNAL("currentIndexChanged(int)"), self.scanTracker.figTracker.set_sub_index)
        QtCore.QObject.connect(self.AxisCombo, QtCore.SIGNAL("currentIndexChanged(int)"), self.scanTracker.figTracker.set_axis_index)
        QtCore.QObject.connect(self.AddPlotProfile, QtCore.SIGNAL("clicked()"), self.scanTracker.figTracker.add_line)
        QtCore.QObject.connect(self.AddAxis, QtCore.SIGNAL("clicked()"), self.scanTracker.figTracker.add_ax)
        QtCore.QObject.connect(self.ColorBar, QtCore.SIGNAL("clicked()"), self.scanTracker.figTracker.add_colorbar)
        QtCore.QObject.connect(self.PlotScansComboCH, QtCore.SIGNAL("currentIndexChanged(int)"), self.scanTracker.figTracker.set_plot_scan_ch)
        QtCore.QObject.connect(self.PlotProfileComboCH, QtCore.SIGNAL("currentIndexChanged(int)"), self.scanTracker.figTracker.set_profile_ch)
        QtCore.QObject.connect(self.PlotScansSpinAlpha, QtCore.SIGNAL("valueChanged(double)"), self.scanTracker.figTracker.set_plot_scan_alpha)
        QtCore.QObject.connect(self.PlotProfileAlpha, QtCore.SIGNAL("valueChanged(double)"), self.scanTracker.figTracker.set_profile_alpha)
        QtCore.QObject.connect(self.PlotProfileCombo, QtCore.SIGNAL("currentIndexChanged(int)"), self.scanTracker.figTracker.set_profile_index)
        QtCore.QObject.connect(self.SliderVmin, QtCore.SIGNAL("valueChanged(int)"), self.scanTracker.figTracker.update_clim)
        QtCore.QObject.connect(self.SliderVmax, QtCore.SIGNAL("valueChanged(int)"), self.scanTracker.figTracker.update_clim)
        QtCore.QObject.connect(self.reverse, QtCore.SIGNAL("stateChanged(int)"), self.scanTracker.figTracker.reverse_cmap)





        QtCore.QObject.connect(self.TransportcomboBox, QtCore.SIGNAL("currentIndexChanged(int)"), self.iv_tracker.set_active_iv)
        QtCore.QObject.connect(self.PlotTrans, QtCore.SIGNAL("clicked()"), self.iv_tracker.plot_active_IV)
        QtCore.QObject.connect(self.ExportTransPort, QtCore.SIGNAL("clicked()"), self.iv_tracker.export_active_IV)



        QtCore.QObject.connect(self.ExportScan, QtCore.SIGNAL("clicked()"), self.export_scan)
        QtCore.QObject.connect(self.ExportProfile_2, QtCore.SIGNAL("clicked()"), self.export_profile)
        #QtCore.QObject.connect(self.RemoveSubPlot, QtCore.SIGNAL("clicked()"), self.ui_tracker.print_poo)

        QtCore.QObject.connect(self.ActivePlotsCombo, QtCore.SIGNAL("currentIndexChanged(int)"), self.scanTracker.figTracker.set_active_plots_index)


        #pyqtgraph
        QtCore.QObject.connect(self.CrossHair, QtCore.SIGNAL("toggled(bool)"), self.ToolTracker.setXhair)
        #QtCore.QObject.connect(self.Line, QtCore.SIGNAL("toggled(bool)"), self.setLine)
        #QtCore.QObject.connect(self.ROI, QtCore.SIGNAL("toggled(bool)"), self.setROI)


        #ToolTracker
        QtCore.QObject.connect(self.singleView, QtCore.SIGNAL("toggled(bool)"), self.ViewTracker.set_Single)
        QtCore.QObject.connect(self.quadView, QtCore.SIGNAL("toggled(bool)"), self.ViewTracker.set_Quad)


        QtCore.QObject.connect(self.ROI, QtCore.SIGNAL("toggled(bool)"), self.ToolTracker.set_Rect)
        QtCore.QObject.connect(self.Line, QtCore.SIGNAL("toggled(bool)"), self.ToolTracker.set_Line)
        QtCore.QObject.connect(self.ROICross, QtCore.SIGNAL("toggled(bool)"), self.ToolTracker.set_roiCross)

        QtCore.QObject.connect(self.Sel, QtCore.SIGNAL("toggled(bool)"), self.ToolTracker.set_Sel)
        QtCore.QObject.connect(self.Vis, QtCore.SIGNAL("toggled(bool)"), self.ToolTracker.set_Vis)
        #QtCore.QObject.connect(self.Vis, QtCore.SIGNAL("toggled(bool)"), self.w5.set_Vis)






    def update_Dwell(self):
        """
        Automatically updates the dwell time displayed for user

        """
        
        self.Dwell = scanobject.scanObjectUtils.dwellTime(OS = self.OS, CH = self.ChannelCount, 
        samples = self.samplesPerPoint, delay = self.delayInt)
        print self.Dwell
        self.dwellT.setText('[ '+ str(self.Dwell)+' us ]')
        self.update_ScanTime()
    
        return


    def update_ScanTime(self):
        """
        Updates the scan time displayed to user
        """
        ScanTime = scanobject.scanObjectUtils.scanTime(Dwell = self.Dwell,pF = self.pointsV, pS = self.pointsH)
        if ScanTime is not None:
            minutes, seconds = divmod(ScanTime, 60)
            hours, minutes = divmod(minutes, 60)
            temp = '{0:0.2f}'.format(seconds)
            label = ''
            if hours > 0:
                label = str(int(hours))+' h: '
            if minutes > 0 or hours > 0:
                label = label + str(int(minutes)) +' m: '

            self.scanT.setText(label + temp + ' s')
        return
        



    def update_OS(self,value):
        self.OS = int(self.Oversampling[int(value)])
        print "Oversampling :",self.OS
        self.update_Dwell()


    #New pyQT stuff gies here::::
    def setXhair(self):
        print self.CrossHair.isChecked()
        if self.CrossHair.isChecked() :
            self.Xhair.show()
            #DEBUG statement show what has active focus I think.. need to test with differnt widgets etc...
            #print str(self.focusWidget())
            #temp = self.focusWidget()
            #print temp.__class__.__name__
            #TODO add a test for temp to see what type it is etc...
            #try :
            #    print str(temp.items())
            #except:
            #    print 'no items here'
            #print str(self.activeWindow())
        else :
            self.Xhair.hide()
        print("hiiii")


    def setROI(self):
        if self.ROI.isChecked() :
            #self.pyROI.show()
            return
        else:
            #self.pyROI.hide()
            return
    def setLine(self):
        print self.Line.isChecked(), 'hiiiii'
        if self.Line.isChecked() :
            self.pyLine.show()
        else :
            self.pyLine.hide()




    def select_file(self):
        """opens a file select dialog"""
        # open the dialog and get the selected file
        file = QtGui.QFileDialog.getOpenFileName()
	
        # if a file is selected
        if file:
            self.filename = str(file)
            self.openScan()

    def openScan(self):
        if  self.filename.endswith('.npz'):
            self.analysisScan = numpy.load(self.filename)
            self.loadScan()
            print 'npz = True'
        elif self.filename.endswith('.scan'):
            self.scans.append(scanobject.scanObjectUtils.load_scanobject(self.filename))
            tempname = self.filename[self.filename.rfind('/'):]
            if self.scans[-1].name == 'test':
                self.scans[-1].name = tempname
            self.ScanCombo.addItem(tempname)
            self.PlotScansCombo.addItem(tempname)
            self.scanTracker.display_scan(len(self.scans)-1) # zero indexed better way maybe?
            self.update_plots_info()
            self.startpoint= None
            self.endpoint = None
        elif self.filename.endswith('.iv'):
            tempname = self.filename[self.filename.rfind('/'):]
            self.iv_tracker.add_iv(scanobject.scanObjectUtils.load_scanobject(self.filename), name = tempname)
            print 'ends with .iv'


    #TODO: figure out if this is redunant with new tracker        
    def update_plots_info(self):
        self.update_view_Ch_index(self.scanTracker.activeScan, self.PlotScansComboCH)
        self.update_view_Ch_index(self.scanTracker.activeScan, self.PlotProfileComboCH)
        prof = len(self.scanTracker.activeScan.profiles)
        self.PlotProfileCombo.clear()
        if prof != 0:
            for i in range(0,prof):
                self.PlotProfileCombo.addItem(self.scanTracker.activeScan.profiles[i].name)

    def update_view_Ch_index(self, scan, combo):
        combo.clear()
        for i in range(0,scan.channelCount):
            combo.addItem(str(i))

    
    def update_active_scan(self, value):
        self.scanTracker.display_scan(value)
        self.update_plots_info()

    def swap_axes(self):
        scanobject.scanObjectUtils.swap_scan_axes(self.scanTracker.activeScan)
        self.scanTracker.activeScan.figures = None #  trashes everything saved in figures only  do before everything else
        self.scanTracker.display_scan()

    def flip_lr(self):
        scanobject.scanObjectUtils.flip_scan_lr(self.scanTracker.activeScan)
        self.scanTracker.activeScan.figures = None 
        #  trashes everything saved in figures only  do before everything else
        self.scanTracker.display_scan()

    def flip_ud(self):
        scanobject.scanObjectUtils.flip_scan_ud(self.scanTracker.activeScan)
        self.scanTracker.activeScan.figures = None 
        #  trashes everything saved in figures only  do before everything else
        self.scanTracker.display_scan()


    #TODO: move to a tracker
    def export_scan(self):
        scan = self.scanTracker.activeScan
        ch_index = self.PlotScansComboCH.currentIndex()
        display_scan = scan.DisplayArray[:,:,ch_index]
        export = Exporter()
        header = export.make_header(scan, ch_index)
        name = '../data/' + scan.name + 'scan_ch' + str(ch_index)
        export.export_csv(name = name, header = header, data = display_scan)

    def export_profile(self):
        scan_name = self.scanTracker.activeScan.name
        profile_index = self.PlotProfileCombo.currentIndex()
        profile = self.scanTracker.activeScan.profiles[profile_index]
        ch_index = self.PlotProfileComboCH.currentIndex()
        data = [profile.profileDataAvg[:,ch_index], profile.Xposition]
        export = Exporter()
        header = export.make_header(profile, ch_index)
        name = '../data/' + scan_name + profile.name + 'scan_ch' + str(ch_index)
        export.export_csv(name = name, header = header, data = data)



    
    #def change_cmap(self, value):
        #self.cmap = pylab.cm._cmapnames[value]



        
   


    #TODO: make this function to display scan info 
    #def displayScanInfo(self):
        #self.analysisScan['displayArray']
        # other metadata in scan includes :units, labels , gain , mag , accel , beam , channel  )





    def getCalBounds(self):
        """
        gets the bounds to calibrate too from a calibration grid using a know standard for x and y and displays them
        """
        self.startH, self.startV, self.endH, self.endV = self.mpl.canvas.ax.viewLim.bounds
        self.calBoundsDislpay.setText('['+'{0:0.2f}'.format(self.startH)+','+'{0:0.2f}'.format(self.startV) + ']['
                                        + '{0:0.2f}'.format(self.endH)+','+'{0:0.2f}'.format(self.endV)+']')

    def getImageBounds(self):
        """
        gets the image bounds that are scanned by SEM imaging.
        This is done to avoid edge effects and distortion from the scan coils
        """
        self.minH, self.minV, self.maxH, self.maxV = self.mpl.canvas.ax.viewLim.bounds
        self.imageBoundDisplay.setText('['+'{0:0.2f}'.format(self.minH)+','+'{0:0.2f}'.format(self.minV) +
                                           ']['+'{0:0.2f}'.format(self.maxH)+','+ '{0:0.2f}'.format(self.maxV)+']')

   
    #TODO: write function to get bounds from ROI
    def getROIBounds(self):
	
	#xdelta = 
	#ydelta = 	
	#offsets =



        return



    def calibration(self):
           
        testMag = float(str(self.Mag.text()))

        #TODO: add this functionality so ROI can be scanned. and update firmware to account for both X and Y
        vMin = int(self.vMin + self.minV*self.stepSize) 
        #  use for all of these parameters  take smallest value and number of points to calculate endpoint
        vMax = int(self.vMin + self.maxV*self.stepSize) #  
        hMin = int(self.hMin + self.minH*self.stepSize)
        hMax = int(self.hMin + self.minH*self.stepSize)

        distanceH = float(str(self.hDistance.text()))
        distanceV = float(str(self.vDistance.text()))
        print distanceV
        print distanceH
        
        pointsH = self.endH - self.startH
        pointsV = self.endV - self.startV

        self.cal = config.setCalibration(testmag = testMag  , testStepSizeH = self.stepSize , testStepSizeV = self.stepSize
                                            ,knownDistanceH = distanceH, knownDistanceV = distanceV, pointsH = pointsH 
                                            , pointsV = pointsV )#, hMax = hMax, hMin = hMin, vMax = vMax, vMin = vMin )


        self.vExtent = self.cal['vMagScale']
        self.hExtent = self.cal['hMagScale']
        self.vMin = self.cal['vMin']
        self.hMin = self.cal['hMin']
        self.hMax = self.cal['hMax']
        self.vMax = self.cal['hMax']


    def runCalScan(self):
        """
        runs StartScan but chnages hMin and vMin to use full scale and not values from config file
        """  

        self.extent =(0, self.xpoints, 0, self.ypoints)      
        self.hMin = -0x7fff
        self.vMin = -0x7fff
        spread = self.stepSize*self.xpoints

        self.takeChannelUnits()
        units = self.channelUnits

        self.takeChannelLabels()
        labels= self.channelLabel

        self.takeChannelGain()
        gain = self.channelGain

        self.mag = str(self.Mag.text())
        mag = self.mag

        self.scanState = scanobject.Scan.setup_scan_state(stepH = self.stepSize, stepV = self.stepSizeV
                                                        , pointsH = self.xpoints, pointsV = self.ypoints
                                                        , spread =[spread,spread], offsets = [0,0], channelMask = self.channelMask
                                                        , delay = self.delay, units = units, labels = labels, gain = gain
                                                        , samples = self.samplesPerPoint, bounds = [self.hMin,self.vMin]
                                                        , mag = self.scanMag)
        self.scanObject = scanobject.Scan( scanstate = self.scanState)
                                            
        self.displayArray=[None]
        self.progress = [None]
        self.scanFlag = [False]
        self.scanData = [None]
        print self.scanState.setupTuple()
       	"""
        self.q = Queue.Queue()

        self.sockQ = edm.socket_to_queue(self.q)

        self.sockQ.start()
       
        
        self.edm = edm.Edm(self.displayArray, self.scanFlag, self.progress, self.scanData, \
        self.scanState, self.scanObject, OS = self.OS, sockQ = self.sockQ, q = self.q)
        self.edm.start()

  	    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
  	    sock.connect((IP, PORT))

  	    sock.send(self.edm.sdm.res)
  	    sock.close()

        self.scan = scanUpdate.ScanUpdate(self, self.mpl, self.img, self.displayArray,self.channel, self.scanFlag, self.scanObject.displayExtent)
        self.scan.start()


        """

        self.q = Queue.Queue()

        if self.sockQ is not None:
            self.sockQ.sock.close()

        self.sockQ = edm.socket_to_queue(self.q, scanFlag = self.scanFlag)

        self.sockQ.start()


        #TODO TM see if we need to shut doen edm if it is still running

        #(self, displayArray, scanFlag, progress, scanData, scanConfig)    
        self.edm = edm.Edm(self.displayArray, self.scanFlag, self.progress, self.scanData,\
        self.scanState, self.scanObject, OS = self.OS, sockQ = self.sockQ, q = self.q) #ScanObject
        #self.edm = edm.Edm([None], [False], [None], [None], scanConfig)
        self.edm.start()

        #SEND COMMAND to start Scan    #needs to be configured then it should go here
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
        sock.connect((IP, PORT))
        sock.send(self.edm.sdm.res)#TODO first place sdm is used
        sock.close()

        #adding unitsto img
        self.img.setUnits( units = self.channelUnits[self.channel[0]])

        #(self, mpl, displayArray, channel, scanFlag)
        self.scan = scanUpdate.ScanUpdate(self,self.mpl,self.img, self.displayArray,self.channel, self.scanFlag, self.scanObject.displayExtent)


        QtCore.QObject.connect(self.scan, QtCore.SIGNAL("update_mpl()"), self.update_mpl)

        QtCore.QObject.connect(self.scan, QtCore.SIGNAL("setup_mpl()"), self.setup_mpl)

        QtCore.QObject.connect(self.scan, QtCore.SIGNAL("update_img()"), self.update_img)

        self.scan.start()

        #Progress Thread
        self.UpdateProgress = scanUpdate.ProgressBarUpdate(self,self.scanFlag)
        QtCore.QObject.connect(self.UpdateProgress, QtCore.SIGNAL("update()"), self.update_progress)

        self.UpdateProgress.start()


	"""
	#Reference for calibration scan
        self.displayArray=[None]
        self.progress = [None]
        self.scanFlag = [False]
        self.scanData = [None]
        print self.scanState.setupTuple()
        
        #(self, displayArray, scanFlag, progress, scanData, scanConfig)    
        self.edm = edm.Edm(self.displayArray, self.scanFlag, self.progress, self.scanData, self.scanState, self.scanObject, OS = self.OS) #ScanObject
        #self.edm = edm.Edm([None], [False], [None], [None], scanConfig)
        self.edm.start()

	#TODO SEND COMMAND to start Scan
	#needs to be configured then it should go here
  	sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
  	sock.connect((IP, PORT))

  	sock.send(self.edm.sdm.res)
  	sock.close()

        #(self, mpl, displayArray, channel, scanFlag)
        self.scan = scanUpdate.ScanUpdate(self.mpl, self.displayArray,self.channel, self.scanFlag, self.scanObject.displayExtent)
        self.scan.start()



	"""




    
    def setThreshold(self, value):
        self.thresholdValue = int(value)



    def test_profile_line(self):
        """
        Starts dialog box sets up call back for communication btwn dialog and Main window and trackers
        """
        self.tempDialog = profileUI.ProfileUI(scan = self.scanTracker.activeScan, callback = self.update_plots_info)
        self.tempDialog.show()
        self.tempDialog.widget.canvas.oneSubPlot()
        self.activeLine = Mfigure.ProfileLine(canvas = self.scanTracker.figTracker.activeCh.canvas
                                                ,ax = self.scanTracker.figTracker.activeCh.canvas.ax, callback = self.temp_profile)

    def temp_profile(self):
        """
        Callback to Dialog that passes info to create profile and plot it
        """
        self.temp_Profile = None
        self.tempDialog.widget.canvas.ax.clear()
        temp_Profile = scanobject.Profile(None, self.activeLine.startpoint.get_offsets()[0]
                                            , self.activeLine.endpoint.get_offsets()[0], self.scanTracker.activeScan)
        self.tempDialog.set_tempprofile(temp_Profile)
        self.tempDialog.plot_profile()




    def startRCSlice(self):
        self.tempSlice = rCenSliceUI.ReCenterSliceUI(scan = self.scanTracker.activeScan, callback = None, mainUI = self)
        self.tempSlice.show()
        self.tempSlice.widget.canvas.oneSubPlot()



            





    #TODO: fix this so it is a combobox that only has the active channels that are selected    
    def setChannel(self,value):
        self.channel[0] = int(value)
        print "channel :",self.channel
        self.img.setUnits(units = self.channelUnits[int(value)])


        
    #def reverseCmap(self):
    #    int(self.reverse.isChecked())




    def setMask(self,chmask):
        self.channelMask=chmask
        self.ChannelCount = EbicDataManager.DataManagerUtils.maskToChannelCount(self.channelMask)
        self.update_Dwell()



        # adding keyword indexing to functions, easier to read make more sense to keep track of things
        # TODO: make seperate values to select, preferably from some config file for each microscope 
    def setStep(self, value, stepV = 255, stepH = 255):
        stepIndex=8+value
        self.stepSize = 2**16/2**stepIndex -1
        self.stepSizeV = 2**16/2**stepIndex -1 #TODO: not active will soon have seperate step sizes for both
        self.xpoints=2**stepIndex -1 #starts from zero
        self.ypoints=2**stepIndex -1
        print(self.xpoints)
        print(self.ypoints)

        
    def setSamplesPerPoint(self,value):
        self.samplesPerPoint=int(value)
        # print(value)
        self.update_Dwell()
        


    def setDelay(self,delayVal):
        """
        sets delay using two shorts (fine and coarse) works in micro controller clock cylces.  
        delay is between new position and sample times
        """
        self.delay= float(delayVal)
        # print "delay is ", self.delay

        #added to update dwell time
        delayFine, delayCoarse = scanobject.Scan.setDelay(self.delay)
        self.delayInt = delayFine
        self.update_Dwell()
        



    def setMag(self,mag):
        """
        sets the Mag if it is not empty 
        """
        self.scanMag=float(mag)

        if self.scanMag != None:
            self.scanScaleH = scanobject.Scan.scale(self.hMagScale, self.scanMag)
            self.scanScaleV = scanobject.Scan.scale(self.vMagScale, self.scanMag)
        # print self.scanScaleH, self.scanScaleV
        # TODO: make it so if the mag is changed no ROI scan is possible 
            self.extentH = self.hSpread * self.scanScaleH
            self.extentV = self.vSpread * self.scanScaleV
            self.mpl.canvas.ax.set_xbound(lower = 0, upper = self.extentH)
            self.mpl.canvas.ax.set_ybound(lower = 0, upper = self.extentV)
            self.mpl.canvas.ax.set_aspect('equal')
            self.mpl.canvas.draw()
            self.setDx(self.Dx)
            


#TODO these seem like they should be apart of a tracker instead of main gui
    def setDx(self,dx):
        """
        gets the value for Dx in position
        """
        if dx != 0:
            self.Dx = float(dx)
            self.Dy = self.Dx
            self.scale = self.Dx*1e-6
            print "Scale ", self.scale
            if self.scanMag is not None:
                self.stepH = scanobject.Scan.step_from_distance(self.Dx, self.scanScaleH)
                self.stepV = scanobject.Scan.step_from_distance(self.Dy, self.scanScaleV)
                print "stepH = ",self.stepH
                xdelta = self.mpl.canvas.ax.viewLim.width
		
		#xdelta = self.img.selROI.get_xdelta() 
                #TODO update this to get fromSELROI....
                self.extentH = scanobject.Scan.scale_extent(abs(xdelta), self.scanScaleH)
                self.pointsH, self.spreadH = scanobject.Scan.scan_points(extent = self.extentH, step = self.stepH)
                print "pointsH = ",self.pointsH,"spreadH", self.spreadH
                print "stepV = " , self.stepV
                ydelta = self.mpl.canvas.ax.viewLim.height
		#ydelta = self.img.selROI.get_ydelta()
                self.extentV = scanobject.Scan.scale_extent(abs(ydelta), self.scanScaleV)
                self.pointsV, self.spreadV = scanobject.Scan.scan_points(extent = self.extentV, step = self.stepV)
                print "pointsV = ", self.pointsV, "spreadV = ", self.spreadV
                self.get_offset()
                self.setROIdim()
                self.update_Dwell()
 
#TODO these seem like they should be apart of a tracker instead of main gui
    def setROIdim(self):
        if self.pointsH != None and self.pointsV != None:
            self.ROIdim.setText('['+ str(self.pointsH)+','+ str(self.pointsV) + ']')

#TODO these seem like they should be apart of a tracker instead of main gui
#TODO remove this is disabled
    def setDy(self):
        """
        gets the value for Dy in position
        """
        return

#TODO these seem like they should be apart of a tracker instead of main gui
    def get_offset(self):
        offsets = self.mpl.canvas.ax.viewLim._get_p0()
	#offsets = self.img.selROI.get_Po()
        #TODO shove the SELROI in here and get the offesets for a ROI Scan set default scan as [0,0] we need to keep track of the state of this
        print offsets, 'vielim p0 \n'
        self.offsets = scanobject.scanObjectUtils.scale_size(offsets, numpy.array([self.scanScaleH, self.scanScaleV]))
        print "DAC offsets are:", self.offsets
        return self.offsets


    def update_scan_ROI(self):
        #self.setDy()
        self.setDx()


    def setAux1(self):  
        #TODO have a seperat function  that send this stuff out      
        Aux1 = self.Aux1Spin.value()
        vstep = 20.0/0xffff
        V = numpy.int16(Aux1/vstep)

        SetV.SendV(V1 = V, CTRL = 0b01)
        self.Aux1Value.setText(str(self.Aux1Spin.value()))

    def setAux2(self):        
        Aux2 = self.Aux2Spin.value()
        vstep = 20.0/0xffff
        V = numpy.int16(Aux2/vstep)

        SetV.SendV(V2 = V, CTRL = 0b10)
        self.Aux2Value.setText(str(self.Aux2Spin.value()))

    def stopScan(self):
        if self.scan is not None:
            #pass
            #self.scan.close()

            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
            sock.connect((IP, PORT))
            sock.send(self.edm.sdm.stopCommand)#TODO first place sdm is used
            sock.close()
            self.scanFlag[0] = True


    def startScan(self):
        
        if self.scan is not None:
            pass
            #self.scan.close()
    
        self.scanBounds = (tuple(self.offsets), (self.offsets[0] + self.spreadH, self.offsets[1] + self.spreadV))
        # Get active scan settings and store them locally
        #self.takeChannelUnits()
        units = self.channelUnits

        #self.takeChannelLabels()
        labels= self.channelLabel

        #self.takeChannelGain()
        gain = self.channelGain

        #self.mag = str(self.Mag.text())
        mag = self.mag

        self.beam = str(self.BeamCurrent.text())
        beam = self.beam

        self.accel = str(self.KV.text())
        accel = self.accel

        Notes = unicode(self.Notes.toPlainText())

        SEMstate = dict([('beam', beam),('accel', accel)])

        channel = self.channelMask

        self.scanInfo=[units,labels,gain,mag,accel,beam,channel]

        self.scanState = scanobject.Scan.setup_scan_state(stepH = self.stepH, \
        stepV = self.stepV, pointsH = self.pointsH, pointsV = self.pointsV, \
        spread =[self.spreadH,self.spreadV],offsets = self.offsets, channelMask = self.channelMask\
        , units= units ,labels = labels ,gain= gain , delay = self.delay\
        , samples = self.samplesPerPoint, bounds = [self.hMin,self.vMin], mag = self.scanMag)
        # TODO:need to have name be something other than test user defined!

        self.scanObject = scanobject.Scan( bounds = self.scanBounds, scanstate = self.scanState, \
        cal = self.cal, name = 'test', SEMstate = SEMstate, Notes = Notes )


        self.displayArray=[None]
        self.progress = [0.0]
        self.scanFlag = [False]
        self.scanData = [None]
        print self.scanState.setupTuple()
        
        self.q = Queue.Queue()

        if self.sockQ is not None:
            self.sockQ.sock.close()

        self.sockQ = edm.socket_to_queue(self.q, scanFlag = self.scanFlag)

        self.sockQ.start()


        #TODO TM see if we need to shut doen edm if it is still running

        #(self, displayArray, scanFlag, progress, scanData, scanConfig)    
        self.edm = edm.Edm(self.displayArray, self.scanFlag, self.progress, self.scanData,\
        self.scanState, self.scanObject, OS = self.OS, sockQ = self.sockQ, q = self.q) #ScanObject
        #self.edm = edm.Edm([None], [False], [None], [None], scanConfig)
        self.edm.start()

        #SEND COMMAND to start Scan    #needs to be configured then it should go here
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
        sock.connect((IP, PORT))
        sock.send(self.edm.sdm.res)#TODO first place sdm is used
        sock.close()

        #adding unitsto img
        #self.img.setUnits( units = self.channelUnits[self.channel[0]])

        #(self, mpl, displayArray, channel, scanFlag)
        self.scan = scanUpdate.ScanUpdate(self,self.mpl,self.img, self.displayArray,self.channel, self.scanFlag, self.scanObject.displayExtent)


        QtCore.QObject.connect(self.scan, QtCore.SIGNAL("update_mpl()"), self.update_mpl)

        QtCore.QObject.connect(self.scan, QtCore.SIGNAL("setup_mpl()"), self.setup_mpl)

        QtCore.QObject.connect(self.scan, QtCore.SIGNAL("update_img()"), self.update_img)

        self.scan.start()

        #Progress Thread
        self.UpdateProgress = scanUpdate.ProgressBarUpdate(self,self.scanFlag)
        QtCore.QObject.connect(self.UpdateProgress, QtCore.SIGNAL("update()"), self.update_progress)

        self.UpdateProgress.start()

        #TODO get ima scale to work with ROI Line etc....
        #self.img.scale(self.scale, self.scale)
        #self.view.setScale(self.scale)
        #self.view.autoRange()
 

    def update_progress(self):    
        self.progressBar_3.setValue(self.progress[0])


    def update_mpl(self):        
        self.im.set_array(self.displayArray[0][:,:,self.channel[0]])
        self.im.autoscale()
        self.mpl.canvas.draw()
        return

    def setup_mpl(self):    
        self.im = self.mpl.canvas.ax.imshow(self.displayArray[0][:,:,self.channel[0]] , cmap= pylab.cm.Greys_r, 
                   extent = self.scanObject.displayExtent, origin='lower', interpolation = 'nearest', alpha = 1 , aspect = 'equal')
        self.mpl.canvas.draw()
        return

    def update_img(self):
        self.img.setImage(numpy.swapaxes(self.displayArray[0][:,:,self.channel[0]], 0,1))

        return


        



    def takeIV(self):

        #TODO change this to use the new firmware and probably a new scan object etc...
        #if self.Aux1En.isChecked():
        Start = self.Aux1SpinMin.value()
        delay = float(str(self.delayAux1.text()))
        End = self.Aux1SpinMax.value()
        step = self.Aux1SpinStep.value()
        gain = float(str(self.TransGain.text()))
        channel = (1 << self.TransChannel.value())
        print "IV channel is:",channel
        self.transport = scanobject.Transport(Start = Start, delay = delay, End = End, step = step, channelMask = channel, gain = gain)
        self.scanFlag = [False]
        self.edm = edm.Edm(scanFlag = self.scanFlag, Transport = self.transport)
        self.edm.start()
        self.tranScan = scanUpdate.TransUpdate(self.mpl_2, self.scanFlag, self.transport)
        self.tranScan.start()  
        
        

    def takeChannelUnits(self,units):
        self.channelUnits=units


    def takeChannelGain(self,gains):
        self.channelGain=gains
        
    def takeChannelLabels(self,labels):
        self.channelLabel=labels
        
    #TODO: make load function that reads in the saved data and displays those channels    
    def saveScan(self):
        #self.scanInfo=[units,labels,gain,mag,accel,beam,channel]
        #self.scanData
        numpy.savez('../data/'+(str(self.saveName.text()) + '_Scan_'+'.npz'), displayArray = self.displayArray[0], scanData = self.scanData[0], 
            units = self.scanInfo[0], labels = self.scanInfo[1] , gain = self.scanInfo[2], mag = self.scanInfo[3], accel = self.scanInfo[4] ,
             beam = self.scanInfo[5], channel = self.scanInfo[6], vExtent = self.vExtent, hExtent = self.hExtent, vMin = self.vMin,
             hMin = self.hMax, vMax = self.vMax )

    def saveScanObject(self,fileName):
            scanobject.scanObjectUtils.pickle_scanobject(self.scanObject , '../data/' + fileName + '.scan')
        

    def saveTransport(self):
            scanobject.scanObjectUtils.pickle_scanobject(self.transport ,  '../data/' + str(self.SweepName.text()) + '.iv')


    
# create the GUI application
app = QtGui.QApplication(sys.argv)
# instantiate the main window
poo = DesignerMainWindow()
# show it
#poo.show()
# start the Qt main loop execution, exiting from this script
# with the same return code of Qt application
#sys.exit(app.exec_())
